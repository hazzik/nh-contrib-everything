==**Why Is Burrow Needed?**==
Burrow is a light weight middleware developed to support .Net applications using NHibernate as ORM framework.  
Using Asp.net with NHibernate could be a challenge because of the fact that NHibernate is a stateful environment while Asp.net is a stateless framework. Burrow can help solve this conflict by providing advanced and transparent session management and other facilitates. 
 
By default, Burrow provide transparent OpenSessionInView support, that is, one NHibernate session and one transaction per http request. At the begining of the http request, a NH ISession is created, a NH transaction is started. At the very end of the http request, the NH transaction is committed and the ISession is closed. This pattern is proved to be sound and good enough most of the time, but the one of the real power Burrow provide is the Burrow conversation. Burrow conversation was inspired by the Conversation concept in  [[http://www.jboss.com/products/seam|JBoss Seam ]]. Put it simple, Conversation allows end user to have a stateful business transaction with the system that spans over multiple http request and response. For example the checkout process is a typical business transaction that spans over multple request/response dilagues - user needs to enter shipping information, billing information and confirm the order information. Like in Seam, one user can have multiple Burrow conversations with the system simultaneously. 
 
 
==Main Features of Burrow==
* **transparent OpenSessionInView Session management** 
* **Burrow Conversation**. support multi request/response business transaction
* **GenericDAO**  with which ISession can be seldom touched most of the time
* **Stateful field attributes** with which marked fields of Asp.net UserControl and Page will be stateful over multiple http requests. It helps UserControls or Pages remember entity without causing lazy load exception.
* **easy multiple databases support**. multiple databases becomes easy, you don't need a SessionFactoryPath, you simply give Burrow an entity type, and Burrow will find the right ISession for you. If you are using GenericDAO, the multiple DB support can be very transparent - your code does not need to know there are multple databases.    




==**A Simple Example about How MindLib Makes It Easy**==
Now let's use a sample project with some sample code to demonstrate what exactly those features mean. This project is a sample donation system with three entities in the domain layer: User, Donation and Payment. User can place donations with payments. User and Donation is in one-to-many relationship, while Donation and Payment is in a One-to-One relationship. To make it simple, each entity has only a few properties. Let's start with a UserCRUD UserControl in the presentation layer that can be used to manage the User entity:
The user entity: User.cs

[[code]]
public class User {
private int id;
private string name;
private User() {}
public User(string name) {
    Name = name;
}
public int Id {
    get { return id; }   private set { id = value; }
}
public string Name {
    get { return name; }   set { name = value; }
}
}
[[code]]

UserCRUD.ascx:
[[code format="blitzbasic"]]
<asp:textbox id="tbName" runat="server" />
<asp:Button ID="btnUpdate" runat="server" Text="Update" OnClick="btnUpdate_Click" />
<asp:Button ID="btnDelete" runat="server" Text="Delete" OnClick="btnDelete_Click" />
<asp:Button ID="btnCreate" runat="server" Text="Create" OnClick="btnCreate_Click" />
[[code]]

On the code behind side:
[[code]]
public partial class UserCRUD : UserControl {
[EntityField] protected User user; //this field value is persistent over requests

public void BindUser(User u) {
    user = u;
    tbName.Text = user.Name;
}
    protected void btnUpdate_Click(object sender, EventArgs e) {
    user.Name = tbName.Text;
}
protected void btnDelete_Click(object sender, EventArgs e) {
    new UserDAO().Delete(user);
    user = null;
}
protected void btnCreate_Click(object sender, EventArgs e) {
    user = new User(tbName.Text);
    new UserDAO().Save(user);
}
}
[[code]]

UserDAO.cs is the DAO of User inherited from the MindLib generic DAO base,
[[code]]
public class UserDAO : MindHarbor.DomainTemplate.NHDomain.GenericDAOBase<User>{}
[[code]]

This is simple and easy, isn't it? The two magic lines here are
//[EntityField] protected User user;//
and
//public class UserDAO : MindHarbor.DomainTemplate.NHDomain.GenericDAOBase<User>//
The [EntityField] attribute marks the user field as Stateful field so that the MindLib will automatically maintain its value status for you. You don't need to directly use either ViewState or HttpSession. [EntityField] can only be used upon fields that are of entity type - classes that are mapped in NHibernate. There is another attribute [StatefulField] that you can use with serializable non-entity object, which we will see later. Currently these attributes can only be used upon protected or public fields.

The UserDAO takes advantage of MindLib's Generic DAO base. I would assume you are familiar with this generic DAO concept, but if you are not, articles about such concept can be easily found. You can create you own DAO without the inheritance, in which case you will probably need to get the NHibernate session. Then you need to remember the following line.
ISession sess = MindHarbor.DomainTemplate.NHDomain.SessionManager.Instance.GetSession();
However, it's highly recommended to use the GenericDAOBase, as it provides a lot of useful helper method with which you can easily query with HQL or CriteriaAPI without touching the NHibernate session directly. Since this NHibernate session is managed by MindLib, 99.9% of the time, query and ICriteria is the only thing you need.
[[#Conversation]]
Actually if you use EntityField together with [[http://msdn.microsoft.com/msdnmag/issues/06/12/ExtendASPNET/default.aspx|Rich Strahl's two-way data binding control]], you can make it even simpler - especially on the code-behind side. [[Two-way data binding|Here is how.]]

==**MindLib Conversation**==
Now let me demonstrate the MindLib conversation by introducing a relatively more complex example of Converstation. This is a simplified donation use case with the following steps, each in a respective pair of http request response:
# the user first tells who she is, the system creates a User object accordingly
# the user enters the total amount of money he wants to donate, the system create the Donation object and set the "Total" property accordingly
# the user enter the credit card information, the system then create the Payment object for the Donation object
# the system display the overall information and the user confirm
# the system store the donation to the database
The domain entities:

[[code]]
public class Donation {
private int id;
private Payment payment;
private float total;
private User user;
public Donation(User user) {
   this.user = user;
}
private Donation() {}
public int Id {
   get { return id; } private set { id = value; }
}
public float Total {
   get { return total; } set { total = value; }
}
public Payment Payment {
    get { return payment; } internal set { payment = value; }
}
public User User {
    get { return user; } set { user = value; }
}
}

public class Payment{
private Donation donation;
private string ccNum;
private float total;
private int id;
public int Id {
    get { return id; } set { id = value; }
}
public float Total {
    get { return total; } set { total = value; }
}

public string CCNum {
    get { return ccNum; } set { ccNum = value; }
}
public Donation Donation {
    get { return donation; } private set { donation = value; }
}
private Payment() {}
public Payment(Donation donation) {
    this.donation = donation;
    this.total = donation.Total;
    donation.Payment = this;
}
}
[[code]]


Checkout.aspx
[[code format="HTML"]]
 Welcome <asp:Literal ID="lUserName" runat="server">Guest</asp:Literal><br />
Step: <asp:Literal ID="lVTest" runat="server"></asp:Literal><br />
<asp:PlaceHolder ID="phLogin" runat="server" >
    Who are you: <asp:TextBox ID="tbUserName" runat="server"></asp:TextBox>
    <asp:Button ID="btnLogin" runat="server" Text="Enter" OnClick="Login" />
</asp:PlaceHolder>
<asp:PlaceHolder ID="phEnterTotal" runat="server" Visible="false" >
    How much you wanna donate: <asp:TextBox ID="tbTotal" runat="server"></asp:TextBox>
    <asp:Button ID="btnEnterTotal" runat="server" Text="Next" OnClick="CreateDonation" />
</asp:PlaceHolder>
<asp:PlaceHolder ID="phEnterCCNum" runat="server" Visible="false" >
    Please enter your credit card Number:
    <asp:TextBox ID="tbCCNum" runat="server"></asp:TextBox>
    <asp:Button ID="btnEnterCCNum" runat="server" Text="Next" OnClick="EnterCCNum" />
</asp:PlaceHolder>
<asp:PlaceHolder ID="phConfirm" runat="server" Visible="false" >
    Total: <asp:Literal ID="lTotal" runat="server"></asp:Literal> <br />
    CCNum: <asp:Literal ID="lCCNum" runat="server"></asp:Literal> <br />
    <asp:Button ID="btnConfirm" runat="server" Text="Confirm" OnClick="PlaceDonation" />
</asp:PlaceHolder>
[[code]]

Checkout.aspx.cs
[[code]]
public partial class Pages_Checkout : Page {
//the placing Donation object is stored in the Conversational field
[ConversationalField] protected Donation placingDonation;
[StatefulField] protected int step = 0;
[EntityField] protected User u;
protected void Login(object sender, EventArgs e) {
    u = new User(tbUserName.Text);
    new UserDAO().Save(u);
    lUserName.Text = u.Name;
    phLogin.Visible = false;
    phEnterTotal.Visible = true;
}

protected void CreateDonation(object sender, EventArgs e) {
    //This line tells our MindLib Framework to start a Conversation
    DomainContext.Current.StarLongConversation();
    placingDonation = new Donation(u);
    placingDonation.Total = Convert.ToSingle(tbTotal.Text);
    phEnterTotal.Visible = false;
    phEnterCCNum.Visible = true;
}
protected void EnterCCNum(object sender, EventArgs e) {
    Payment payment = new Payment(placingDonation);
    payment.CCNum = tbCCNum.Text;
    phEnterCCNum.Visible = false;
    phConfirm.Visible = true;
    //display the full donation information in the Confirmation window
    lTotal.Text = donation.Total.ToString("C");
    lCCNum.Text = donation.Payment.CCNum;
    lUserName.Text = u.Name;
            }

protected void PlaceDonation(object sender, EventArgs e) {
    //save the conversational data to Database at the last step
    new DonationDAO().Save( placingDonation);
    //This line tells our MindHarbor Framework to finish the Conversation
    DomainContext.Current.FinishConversation();
    //it is a good practice to reset the conversational data to null afterwards
    placingDonation = null;
}

protected override void OnPreRender(EventArgs e) {
    step++;
    lVTest.Text = step.ToString(); //update the current step number
    base.OnPreRender(e);
}

}
[[code]]

The entities are simple, actually I separate payment information into the Payment class just to make things a little more interesting. Now let's look at the code behind file to see the typical code with the conversation. There are four button click event handler methods each proceeds to the next step. In the first step Login(), a User entity is created and stored in the [EntityField] protected User u. Then in the second step (), after user enters a total amount of the intended donation, the code first command MindLib to start a Long Conversation (conversation that span over multiple request):
DomainContext.Current.StarLongConversation();
Then the code created a donation instance and store it in the placingDonation field. Note that the placingDonation field is marked with [ConversationalField] rather than [EntityField] although it's an entity. The reason here is that this placingDonation should be discard along with the conversation if the conversation is abandoned. Another reason is that the EntityField actually needs the Id of the entity which is not yet available here since it's not stored to the database yet. In the next step, a payment is created and attached to the placingDonation (this logic is in Payment's constructor). Please also note that these attributes can only be used upon protected or public fields.

Then in the final step PlaceDonation(), after user's confirmation, the code persists the placingDonation and command the MindLib to finish the conversation. In this process, user can leave at any step without actually placing the donation. Nothing will happen to the database util the final step. In another sentence, it's one atomic transaction.
Now that we have a basic idea of how MindLib conversation works, let's go over some main traits of it:
* Conversation is atomic. Bascially one conversation is one long NHibernate session and one database transaction. Either all or none of the operations happens within the conversation will take effect.
* Conversation is isolated. Not only conversations from different users won't affect each other, one user can actually simultaneously have multiple conversations with multiple browser windows. It's similar to the concept of workspace from Seam. In our example, one user can open two browser window/tab and proceed two donations at the same time.
* Abandoned conversation (user close the browser or leaves the computer) will be garbage collected after timeout.
* Currently conversation only continue in post httpRequests, if user switch to another page by a link, she will leave the conversation.
Also you might notice the line: [StatefulField]protected int step, [StatefulField] is for you to mark a Non-Entity type field to be stateful. Non-Entity types means primitive types or classes that are not mapped in NHibernate and are serializable. One thing to note is that when using long conversation, you may need to change your isolation level to lower than ReadUncommitted, otherwise the transaction in conversation might block other transactions.

==**Transparent Multi-Database support**==
The last main MindLib feature I haven't show you is the transparent multiple databases support. As it is transparent, there isn't much code I can show as it's the same as if the code is written for one single database. The only difference will in the configuration where you define which domain assembly use which database.


==**Get Started**==
If you already reached this point, you probably want to give it a try. MindLib is now a GPL open source project hosted on SourceForge @ [[http://mindlib.sf.net./|http://MindLib.sf.net.]] Here is the[[QuickStart| link to a quick start tutorial]]. There is also a sample project included in the MindLib source. [[Sample Project|Here]] is how to setup it up.