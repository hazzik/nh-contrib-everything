<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NHibernate.Burrow</name>
    </assembly>
    <members>
        <member name="T:NHibernate.Burrow.Util.EntityBases.IWithIdNBizKey">
            <summary>
            interface for object that has business Key
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Util.EntityBases.IWithId">
            <summary>
            Class with an Integer Id that can identify persistant instances.
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Util.EntityBases.IWithId.Id">
            <summary>
            the integer Id that can identify persistant instances.
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Util.EntityBases.IWithIdNBizKey.BusinessKey">
            <summary>
            A businesskey is a property that can uniquely identify the the entity from others of the same type.
            </summary>
            <remarks>
            It's somewhat similar to concept of primary key in relational database
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.IConversation">
             <summary>
            
             </summary>
        </member>
        <member name="M:NHibernate.Burrow.IConversation.SpanWithCookie(System.String)">
            <summary>
            Span with Http Session
            </summary>
            <returns></returns>
            <remarks>
            The conversation will be available to all requests that shares the same HttpSession
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.IConversation.SpanWithPostBacks">
            <summary>
            Span with a chain of post http requests
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.IConversation.GiveUp">
            <summary>
            Give up the data change made in this conversation
            </summary>
            <remarks>
            This won't imediately close the conversation, it tells the conversation not to commit the DB change when it is closed. 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.IConversation.FinishSpan">
            <summary>
            tells the conversation to stop spanning itself and commit the data change made in it when it's closed
            </summary>
            <returns></returns>
            <remarks>
            call this method when all operations in a long span conversation are successfully done
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.IConversation.Id">
            <summary>
            Gets the unique id of this conversation
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IConversation.IsSpanning">
            <summary>
            Gets if this conversation is Spanning (either with Postbacks or HttpSessions)
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IConversation.SafeItems">
            <summary>
            Gets the safe data bag the conversation holds
            </summary>
            <remarks>
            You can use this item to store conversation span data. It's safer as it requires you to use a GUID as key.
            Basically this is a dictionary that uses guid as keys. 
            Another more convenient and better way to  safely store datathat share the same life span as conversation is the <see cref="T:NHibernate.Burrow.ConversationalData`1"/>
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.IConversation.Items">
            <summary>
            Gets the data bag the conversation holds. You can use this item to store conversation span data.
            </summary>
            <remarks>
            You can use it as how you want. As it's using string as key, you might have key conflict problem, for safer conversational bag, you can use SafeItems
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.IConversation.WorkSpaceName">
            <summary>
            Gets the string WorkSpace name, 
            </summary>
            <remarks>
            the workSpaceName define the group of pages/handlers within which it spans, 
            if not null or empty, the conversation will span within the pages/handlers with the same workSpaceName
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.IConversation.LastVisit">
            <summary>
            Gets the last time this conversation is visited
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.ConversationPool.Item(System.Guid)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            
            <returns>
            The element with the specified key.
            </returns>
            
            <param name="key">The key of the element to get or set.</param>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="T:NHibernate.Burrow.Impl.ConversationPoolItem">
            <summary>
            
            </summary>
            <remark>
            not sure if this is needed any more as I moved both timeout and last visited information into <see cref="F:NHibernate.Burrow.Impl.ConversationPoolItem.conversation"/>
            but it still maybe needed in the future, so I keep it here. 
            </remark>
        </member>
        <member name="T:NHibernate.Burrow.DataContainers.GuidDataContainer">
            <summary>
            A data container which uses guid as key
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Configuration.PersistenceUnitElement">
            <summary>
            Configuration Section for a Persistence Unit
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.PersistenceUnitElement.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.PersistenceUnitElement.NHConfigFile">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.PersistenceUnitElement.ManualTransactionManagement">
            <summary>
             wheather the transaction under this persistence Unit is manually managed by client    
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IConversationExpirationChecker.CleanUpTimeSpan">
            <summary>
            Gets the period for the conversation pool cleaning.
            </summary>
            <remarks>
            in another sentence, it articulates the frequency of the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/>'s cleaning of expired <see cref="T:NHibernate.Burrow.Impl.ConversationImpl"/>. 
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.DataContainers.LocalSafe`1">
            <summary>
            This storage wrapper can be used as a static field and will garuntee localness - either HttpContext local if in a HttpContext environment or ThreadLocal otherwise 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NHibernate.Burrow.Util.WebUtil.WrapUrlWithConversationInfo(System.String)">
            <summary>
            Wraps a url with Conversation Information so that conversation can span with Request query
            </summary>
            <param name="originalUrl"></param>
            <returns></returns>
            <remarks>
            Please deter calling this method as late as possible. And only call it when you are spanning the conversation. 
            If you wrap a url with conversation info and finish or cancel that conversation later in the same request handle, hitting the url will cause a conversationUnavailable error.
            </remarks>
            <exception cref="T:NHibernate.Burrow.Exceptions.IncorrectConversationSpanStatusException">
            thrown if called when the current conversation isn't spanning. 
            </exception>
        </member>
        <member name="T:NHibernate.Burrow.Util.DAOBases.EntityLoader">
            <summary>
            A generic helper loader for loading persistant object by Id
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.EntityLoader.Load(System.Type,System.Object)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.EntityLoader.Get(System.Type,System.Object)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Burrow.Util.DAOBases.EntityLoader.Instance">
            <summary>
            a instance of the loader
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.PersistenceUnit">
            <summary>
            A persistant Unit is a unit of a ORM management
            </summary>
            <remarks>
            it consists of a Database, a NHibernate SessionManager, a Nhibernate SessionFactory.
            It can be shared by multiple domain layer assemblies 
            It's heavy weight
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.PersistenceUnit.ReBuildSessionfactory">
            <summary>
            Rebuild the Session factory
            </summary>
            <remarks>
            in case you need to change the NHConfiguration on the fly
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.PersistenceUnit.CreateNHConfiguration">
            <summary>
             Create a NHibernate Configuration
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Burrow.Impl.PersistenceUnit.Name">
            <summary>
            the name of the PU
            </summary>
            <remarks>
            Set at the configuration File
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.PersistenceUnit.Configuration">
            <summary>
            The configuration section that sets this Persistence Unit in the configuration file
            </summary>
            <remarks>
            This class stored the setting information associated with this PU
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.PersistenceUnit.NHConfiguration">
            <summary>
            The nhibernate configuration of this session Manager
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.VoidTransactionManager">
            <summary>
            a transaction manager that does no transaction management
            </summary>
            <remarks>
            this is for in manual transaction mode, so that client can control the transaction itself.
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ITransactionManager.BeginTransaction(NHibernate.ISession)">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Exceptions.BurrowException">
            <summary>
            Summary description for DomainException.
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Exceptions.BurrowException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Exceptions.BurrowException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:NHibernate.Burrow.Exceptions.BurrowException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="msg"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase">
            <summary>
            A base class that has an integer Identity that can be used to identify the persistant object, and a business key <see cref="P:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase.BusinessKey"/> for calculating equality
            </summary>
            <remarks>
            The purpose of inheriting this class is to inherit its Equals() and GetHashCode()
            which were properly overriden for the has-Id characteristic.
            The Equals() and GetHashCode() methods have the following behavior: 
            the two objects are Equal and have the same HashCode when and only when
             1) they are of the same type and 2) the have the same business key 
            This class also offers a default meaningful ToString() method
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.Util.EntityBases.IDeletable">
            <summary>
            an interface for entities that has Deletion logic in itself
            </summary>
        </member>
        <member name="F:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase.BIZKEYSEP">
            <summary>
            Recommend to use this as the seperator of the composite business key
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase.CompareTo(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <remarks>
            User BusinessKey to Compare 
            This method is set as virtual for ORM framework to dynamically create proxy
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase.BusinessKey">
            <summary>
            A BusinessKey (business key) is a property, or some combinatioin of properties, that is unique for each instance with the same database identity.
            Essenstially it's the natural key you'd use if you weren't using a surrogate key. 
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Util.EntityBases.EntityWithIdNBizKeyBase.Id">
            <summary>
            The database identity integer of the class or Surrogate key
            </summary>
            <remarks> 
            This method is set as virtual for ORM framework to dynamically create proxy
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.Impl.SpanStrategy">
            <summary>
            the strategy with which Burrow span the Conversation
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.SpanStrategy.ValidForSpan">
            <summary>
            indicate if this strategy does span
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.SpanStrategy.UrlQueryOnlyStrategy">
            <summary>
            This Strategy span by using Url Query only 
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.IFrameworkEnvironment">
            <summary>
            The Burrow Framework Environment
            </summary>
            <remarks>
            the envrionment that the application resides in.
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.IFrameworkEnvironment.ShutDown">
            <summary>
            ShutDown the whole thing
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IFrameworkEnvironment.SpanningConversations">
            <summary>
            Gets the num of Spanning Conversations
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.FrameworkEnvironment.StartNewWorkSpace(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Initialize a Domain Context 
            </summary>
            <remarks>
            Please read the remarks of the <see cref="T:NHibernate.Burrow.Impl.WorkSpace"/>
            You normally don't need to call this method
            </remarks>
            <param name="states">
            Initialized the domain context with a collection of states
            </param>
            <param name="currentWorkSpaceName"></param>
        </member>
        <member name="M:NHibernate.Burrow.Impl.FrameworkEnvironment.ShutDown">
            <summary>
            ShutDown the whole environment
            </summary>
            <remarks>
            it will roll back every conversation in the pool
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.FrameworkEnvironment.CurrentWorkSpace">
            <summary>
            The currentConversationHolder context conversation
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.FrameworkEnvironment.SpanningConversations">
            <summary>
            Gets the num of Spanning Conversations
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.ConversationExpirationCheckerFactory">
            <summary>
            static factory for <see cref="T:NHibernate.Burrow.IConversationExpirationChecker"/>
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.TransactionManagerImpl.BeginTransaction(NHibernate.ISession)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.TransactionManagerImpl.CommitTransaction">
            <summary>
            Try commit the transaction, if failed the transaction will be rollback and the session will be close
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.TransactionManagerImpl.RollbackTransaction">
            <summary>
            Rollback the Transaction and Close Session
            </summary>
            <remarks>
            if the tranasaction has already been rollback or the session closed this will do nothing. 
            You can perform this method multiple times, only the first time will take effect. 
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.Configuration.PersistenceUnitElementCollection">
            <summary>
            ConfigurationElementCollection for Persistence Unit Section
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Configuration.PersistenceUnitElementCollection.CreateNewElement">
            <summary>
            When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </summary>
            
            <returns>
            A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
            
        </member>
        <member name="M:NHibernate.Burrow.Configuration.PersistenceUnitElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
            
            <returns>
            An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
            </returns>
            
            <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for. </param>
        </member>
        <member name="T:NHibernate.Burrow.BurrowFramework">
            <summary>
            Facade of Burrow 
            </summary>
            <remarks>
            Creating an instance of this class is free. The instance is stateless and can be stored anywhere
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.BurrowFramework.InitWorkSpace">
            <summary>
            a shotcut to <see cref="M:NHibernate.Burrow.BurrowFramework.InitWorkSpace(System.Boolean,System.Collections.Specialized.NameValueCollection,System.String)"/> with (false, null, string.Empty) as the parameter
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.BurrowFramework.InitWorkSpace(System.Boolean,System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
             prepare the Burrow environment for the current visit to your Domain Layer
            </summary>
            <param name="ignoreUnclosedWorkSpace">if there is an existing WorkSpace, ignoreUnclosedWorkSpace = true will close it first. 
                                                ignoreUnclosedWorkSpace = false will throw an Exception .</param>
            <param name="states">the span states that should be used to initialized it, if you are not spanning the conversation, leave it null</param>
            <remarks>
            This should be called before any NHibernate related operation and actually, for example, in the begining of handling a http request
            if you are using  NHibernate.Burrow.WebUtil's HttpModule, as you should in an Web Application, it will call this for you, you don't need to worry about this.
            </remarks>
            <param name="currentWorkSpaceName">the workSpaceName of the current context (usually defined by the handler side)</param>
        </member>
        <member name="M:NHibernate.Burrow.BurrowFramework.InitWorkSpace(System.Guid)">
            <summary>
            Initialize the WorkSpace and join the conversation with <paramref name="conversationId"/>
            </summary>
            <param name="conversationId"></param>
        </member>
        <member name="M:NHibernate.Burrow.BurrowFramework.CloseWorkSpace">
            <summary>
            close the Burrow environment for the current visit to your Domain Layer
            </summary>
            <remarks>
            This should be called after the current visit to the domainlayer is finished and the time of next visit is unknow, for example, at the very end of handling the http request
            if you are using  NHibernate.Burrow.WebUtil's HttpModule, it will call this for you, you don't need to worry about this.
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.BurrowFramework.GetSession">
            <summary>
            overloaded version of <see cref="!:GetSession(Type)"/> in a single-SessionFactory environment
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.BurrowFramework.GetSession(System.Type)">
            <summary>
            Gets a managed ISession
            </summary>
            <param name="entityType"></param>
            <returns></returns>
            <remarks>
            Please do not try to close or commit transaction of this session as its status and transaction are controlled by Burrow
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.BurrowFramework.CurrentConversation">
            <summary>
            Gets the current <see cref="T:NHibernate.Burrow.IConversation"/>
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.BurrowFramework.BurrowEnvironment">
            <summary>
            Gets the <see cref="T:NHibernate.Burrow.IFrameworkEnvironment"/>
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.BurrowFramework.WorkSpaceIsReady">
            <summary>
            gets if the Burrow workspace is already <see cref="M:NHibernate.Burrow.BurrowFramework.InitWorkSpace"/> and not <see cref="M:NHibernate.Burrow.BurrowFramework.CloseWorkSpace"/>  yet.
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.IBurrowConfig.DBConnectionString(System.Type)">
            <summary>
            Get the DBConnectionString for the DB where <paramref name="entityType"/> is persistent in
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Burrow.IBurrowConfig.ConversationTimeOut">
            <summary>
             The converstaion timout minutes
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IBurrowConfig.ConversationCleanupFrequency">
            <summary>
             The conversation clean up frequency,
              for how many times of conversation Timeout,
              the conversation pool clean up its timeoutted converstaions.
              must be greater than 1
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IBurrowConfig.ConversationExpirationChecker">
            <summary>
             The conversation clean up frequency,
              for how many times of conversation Timeout,
              the conversation pool clean up its timeoutted converstaions.
              must be greater than 1
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.IBurrowConfig.WorkSpaceNameSniffer">
            <summary>
            for user to set a customer IWorkSpaceNameSniffer for WebUtil to use
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Util.InstanceLoader">
            <summary>
            A loader writen to load instance of singleton types
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Util.InstanceLoader.LoadByConstrutor(System.Type)">
            <summary>
            Load the singleton of the type by constructor 
            </summary>
            <param name="t"></param>
            <returns>null if there is no public non-parameter constructor</returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.InstanceLoader.LoadByInstanceProperty(System.Type)">
            <summary>
            Load the singleton by static property named "Instance"
            </summary>
            <param name="t"></param>
            <returns>return null if there is no such 
            </returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.InstanceLoader.Load(System.Type)">
            <summary>
            Load the singleton by all means
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.InstanceLoader.Load``1(System.String)">
            <summary>
            Load type by name
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.InstanceLoader.Load``1">
            <summary>
            Generic version of Load(System.Type t)
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <remarks>
            <see cref="!:InstanceLoader.Load(System.Type t)"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.InstanceLoader.Loadable(System.Type)">
            <summary>
            judge if Type t is a loadable singleton
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Burrow.Util.DAOBases.GenericDAO`1">
            <summary>
            A DAO that includes a set of shotcut methods. 
            </summary>
            <typeparam name="ReturnT">Type as which GenericDAO returns entities</typeparam>
            <remarks>
            This DAO can be inherited to add/override functions.
            It's totally optional to client to use it or not, as other classes in the  NHibernate.Burrow.Util namespace 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.#ctor(System.Type)">
            <summary>
            Constructs a GenericDAO whose <typeparamref name="ReturnT"/> is different from the mapped entity type in NHibernate
            </summary>
            <param name="entityTypeMapped"></param>
            <remarks>
            for example, you can use an unmapped interface as <typeparamref name="ReturnT"/> and a mapped implementation type as the entityTypeMapped 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.#ctor">
            <summary>
            Constructs a GenericDAO whose <typeparamref name="ReturnT"/> is mapped in NHibernate
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.ParseOrder(System.String)">
            <summary>
            Parse the NHibernate.Expression.Order from the string sortExpression
            </summary>
            <param name="sortExpression"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.UniqueResult``1(System.Collections.Generic.IList{``0})">
             <summary>
             Gets the unique result from results
             </summary>
             <typeparam name="T"></typeparam>
             <param name="results"></param>
             <returns></returns>
             <remarks>
             you can use this together with other helper methods to do unqiue search
             <example>
             <code>
             public class CustomerDAO : GenericDAO{Customer}  {
                  public Customer FindbyName(string name){
                      return UniqueResult(Find(Expression.Eq( "Name", name)); 
                  }
             }
             </code>
             </example>
            
             </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.CreateQuery(System.String)">
            <summary>
            Create a Hibernate query
            </summary>
            <param name="queryString"></param>
            <returns></returns>
            <remarks>
            <example>
            In most case, the query must start with "select " or "from " like the following
            <code>
            dao.CreateQuery("select tm from Team tm WHERE tm.TeamType = :tt");	
            </code>
            or 
            <code>
            dao.CreateQuery("from Team tm where tm.TeamType = :tt");	
            </code>
            For convenience, as the DAO already know the entity name, if you are query the entity, 
             you can skip the "from XXXX" part of the HQL, the following code is also valide.
            <code>
             dao.CreateQuery("tm where tm.TeamType = :tt");	
            </code>
            this method will automatically add "from Team " before the above query.
            </example>
            <example>
            you can even skip the alias "tm" if you use "this" as the alias for the current entity
            <code>
             dao.CreateQuery("where this.TeamType = :tt");	
             dao.CreateQuery("order by this.CreationTime");	
            </code>
            this method will automatically add "from Team this " before the above query.
            </example>
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.PaginatedQuery(NHibernate.IQuery,System.Int32,System.Int32)">
            <summary>
            Query by page
            </summary>
            <param name="q"></param>
            <param name="startRow"></param>
            <param name="pageSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.CreateCriteria(System.Collections.Generic.IEnumerable{NHibernate.Criterion.ICriterion})">
            <summary>
            Create a criteria using defaultOrder
            </summary>
            <param name="criterions"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.CreateCriteria(NHibernate.Criterion.Order,System.Collections.Generic.IEnumerable{NHibernate.Criterion.ICriterion})">
            <summary>
            Create Criteria using <paramref name="odr"/>
            </summary>
            <param name="odr">can pass null</param>
            <param name="criterion"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.CreateCriteria">
            <summary>
            Create a Criteria without order
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.CreateCriteria(System.String)">
            <summary>
            Create a Criteria instance of the Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Find(NHibernate.Criterion.ICriterion[])">
            <summary>
            Find according the criterion
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Find(System.Int32,System.Int32,NHibernate.ICriteria)">
            <summary>
            Query by creteria with paging surport. 
            </summary>
            <param name="c"></param>
            <param name="pageSize"></param>
            <param name="startRow"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Find(System.Int32,System.Int32,System.String,NHibernate.ICriteria)">
            <summary>
            Find by ICriteria created by client with Pagination and Sorting
            </summary>
            <returns></returns>
            <remarks>
            This pagination signature is designed to work with ASP.NET ObjectDataSource, for more advanced pagination, please consider NHiberante.Burrow.Util.Pagination.IPaginator, NHiberante.Burrow.Util
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Find(System.Int32,System.Int32,System.String,NHibernate.Criterion.ICriterion[])">
            <summary>
            
            </summary>
            <param name="startRow"></param>
            <param name="pageSize"></param>
            <param name="sortExpression">will use <see cref="P:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.DefaultOrder"/> if empty</param>
            <param name="crit"></param>
            <returns></returns>
            <remarks>
            This pagination signature is designed to work with ASP.NET ObjectDataSource, for more advanced pagination, please consider NHiberante.Burrow.Util.Pagination.IPaginator, NHiberante.Burrow.Util
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Find(System.Int32,System.Int32,System.String,System.Collections.Generic.ICollection{NHibernate.Criterion.ICriterion})">
            <summary>
            
            </summary>
            <param name="startRow"></param>
            <param name="pageSize"></param>
            <param name="sortExpression">will use <see cref="P:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.DefaultOrder"/> if empty</param>
            <param name="crit"></param>
            <returns></returns>
            <remarks>
            This pagination signature is designed to work with ASP.NET ObjectDataSource, for more advanced pagination, please consider NHiberante.Burrow.Util.Pagination.IPaginator, NHiberante.Burrow.Util
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Count(System.Collections.Generic.ICollection{NHibernate.Criterion.ICriterion})">
            <summary>
            Count by a collection of Criterion
            </summary>
            <param name="criterions"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Count(NHibernate.ICriteria)">
            <summary>
            Counts the result of <paramref name="c"/>
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Get(System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance, or a proxy for the instance, is already associated with the session, return that instance or proxy.)
            </summary>
            <param name="id"></param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Load(System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, assuming that the instance exists.
            </summary>
            <param name="id"></param>
            <returns>The persistent instance or proxy</returns>
            <remarks>
            You should not use this method to determine if an instance exists (use a query or NHibernate.ISession.Get(System.Type,System.Object) instead). Use this only to retrieve an instance that you assume exists, where non-existence would be an actual error.
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Delete(`0)">
            <summary>
            Delete the record of an entity from Database and thus the entity becomes transient
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Refresh(`0)">
            <summary>
            Re-read the state of the entity from the database
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.SaveOrUpdate(`0)">
            <summary>
            Persist the entity <paramref name="t"/> to DB if it has not been persisted before 
            </summary>
            <param name="t"></param>
            <remarks>
            By default the instance is always saved. 
            This behaviour may be adjusted by specifying an unsaved-value attribute of the identifier property mapping 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Save(`0)">
            <summary>
            Persist the given transient instance, first assigning a generated identifier.  
            </summary>
            <param name="t">the given transient instance</param>
            <returns>The generated identifier
            </returns>
            <remarks>
            Save will use the current value of the identifier property if the Assigned generator is used.
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.FindAll">
            <summary>
            Finds all entities of the type
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.FindAll(System.Int32,System.Int32,System.String)">
            <summary>
            Find all entities of the type with paging and sorting
            </summary>
            <param name="startRow">the index of the first record to return</param>
            <param name="pageSize">the number of the records to return</param>
            <param name="sortExpression">the expression for sorting
            <example> Name DESC </example>
            <example> Year ASC </example>
            this parameter can be IsEmptyOrNull when sorting is not needed
            </param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.CountAll">
            <summary>
            Counts all entities of the type
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.DefaultOrder">
            <summary>
            Default Order when query entities
            </summary>
            <remarks>
            if not override, it will use id Desc, 
            As "id" is reserved in HQL to represent identifier, this should be always safe 
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.DefaultCacheable">
            <summary>
            Gets if the DAO use cacheable query/criteria by default
            </summary>
            <remarks>
            default value is false;
            override to return the value you want
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.DefaultCacheRegion">
            <summary>
            Gets the default cache region 
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Util.DAOBases.GenericDAO`1.Session">
            <summary>
            Gets the Nhibernate Session 
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.SessionManager">
            <summary>
            Handlers creation and management of sessions and transactions. 
            </summary>
            <remarks>
            Lifespan : application, Threadsafe
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.GetUnManagedSession">
            <summary>
            get a un managed session
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.GetSession">
            <summary>
            Get a managed Session
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.CloseSession">
            <summary>
            Close the session.
            </summary>
            <remarks>
            if the session is already closed, this will do nothing
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.BeginTransaction">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.CommitTransaction">
            <summary>
            Try commit the transaction, if failed the transaction will be rollback and the session will be close
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.RollbackTransaction">
            <summary>
            Rollback the Transaction and Close Session
            </summary>
            <remarks>
            if the tranasaction has already been rollback or the session closed this will do nothing. 
            You can perform this method multiple times, only the first time will take effect. 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.SessionManager.GetSession(NHibernate.IInterceptor)">
            <summary>
            Gets a session with or without an interceptor.  This method is not called directly; instead,
            it gets invoked from other public methods.
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.SessionManager.PersistenceUnit">
            <summary>
            The PersistenceUnit it belongs to.
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.WorkSpace">
            <summary>
            Represents the current work space
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.WorkSpace.WrapUrlWithSpanInfo(System.String)">
            <summary>
            
            </summary>
            <param name="originalUrl"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Impl.WorkSpace.Close">
            <summary>
            Close the current domain context. call this after you are done with all the domain operations that requires interaction with NHibernate
            </summary>
            <remarks>
            Please read the remarks of the <see cref="T:NHibernate.Burrow.Impl.WorkSpace"/>
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.WorkSpace.Current">
            <summary>
            The current WorkSpace your code is working in
            </summary>
        </member>
        <member name="F:NHibernate.Burrow.ConversationalDataMode.Normal">
            <summary>
            Data will only be available in conversation it is created, outside of the conversation, exception will be thrown if it is accessed 
            </summary>
        </member>
        <member name="F:NHibernate.Burrow.ConversationalDataMode.OutOfConversationSafe">
            <summary>
            Data will only be available in conversation it is created, once visited outside of the conversation, data will automatically reset to null 
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.ConversationalData`1">
            <summary>
            A Data container for conversational data that needs to have the same life span with a conversation
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            use it when you need some data to have the same life span as the current conversation.
            this class does not actually hold a reference to the <see cref="P:NHibernate.Burrow.ConversationalData`1.Value"/> which is actually stored in <see cref="P:NHibernate.Burrow.IConversation.SafeItems"/> 
            Thus <see cref="T:NHibernate.Burrow.ConversationalData`1"/> can be cheaply serialized and stored. 
            for example, in a Asp.net application, you can put an entity into a ConversationalData(entity) and then save the conversationalData instance into the ViewState or HttpSession 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.ConversationalData`1.#ctor(NHibernate.Burrow.ConversationalDataMode)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.ConversationalData`1.#ctor(`0)">
            <summary>
            
            </summary>
            <param name="value">the real data you want this container to hold</param>
            <remarks>
            The default <see cref="P:NHibernate.Burrow.ConversationalData`1.Mode"/> is <see cref="F:NHibernate.Burrow.ConversationalDataMode.OutOfConversationSafe"/>
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.ConversationalData`1.Value">
            <summary>
            Gets and sets the data stored in this container
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.ConversationalData`1.OutOfConversation">
            <summary>
            indicates if this data is out of conversation 
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Exceptions.GeneralException">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Exceptions.GeneralException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Exceptions.GeneralException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection">
            <summary>
            Root Section for NHibernate.Burrow Configuration
            </summary>
        </member>
        <member name="F:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.SectionName">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.CreateInstance">
            <summary>
            Get the instance from the current application's config file
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.DBConnectionString(System.Type)">
            <summary>
            Get the DBConnectionString for the DB where <paramref name="entityType"/> is persistent in
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.PersistenceUnits">
            <summary>
            
            </summary>
            <remarks>
            Declare a collection element represented 
            in the configuration file by the sub-section
            <![CDATA[
            <persistantUnits> <add .../> </persistantUnits> 
            Note: the "IsDefaultCollection = false" 
            instructs the .NET Framework to build a nested 
            section like <persistantUnits> ...</persistantUnits>.
            ]]>
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.ConversationTimeOut">
            <summary>
             The converstaion timout minutes
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.ConversationCleanupFrequency">
            <summary>
             The conversation clean up frequency,
              for how many times of conversation Timeout,
              the conversation pool clean up its timeoutted converstaions.
              must be greater than 1
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.ConversationExpirationChecker">
            <summary>
             The conversation clean up frequency,
              for how many times of conversation Timeout,
              the conversation pool clean up its timeoutted converstaions.
              must be greater than 1
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Configuration.NHibernateBurrowCfgSection.WorkSpaceNameSniffer">
            <summary>
            for user to set a customer IWorkSpaceNameSniffer for WebUtil to use
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Util.EntityBases.EntityWHashIdBase">
            <summary>
            A base class that use its inital hashcode as its Identity
            </summary>
            <remarks>
            It can be used as a base class for those classes withe whom you canot define a business key easily 
            For this object to work, you should mapped the HashId property in the hbm file
            If you are sure that you use a one session per request pattern you can use entity without business key
            <example>
            <![CDATA[
            <property name="HashId" />
            ]]>
            </example>
            
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Util.EntityBases.EntityWHashIdBase.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Util.EntityBases.EntityWHashIdBase.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            overriden to use the HashId
            This method is kept as virtual for ORM framework to dynamically create proxy
            But it should never be overriden by developer
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Util.EntityBases.EntityWHashIdBase.BusinessKey">
            <summary>
            
            </summary>
            <remarks>
            return the HashId
            </remarks>
        </member>
        <member name="T:NHibernate.Burrow.Impl.PersistenceUnitRepo">
            <summary>
            A repository for the perstitant Units
            </summary>
            <remarks>
            repository instances can be retrieved from here
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.PersistenceUnitRepo.Instance">
            <summary>
            The singleton Instance of this class
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.PersistenceUnitRepo.PersistenceUnits">
            <summary>
            All the existing persistant Units in this application
            </summary>
        </member>
        <member name="T:NHibernate.Burrow.Impl.ConversationImpl">
            <summary>
             Represents a conversation between user and the system
            </summary>
             <remarks>
             Actually you shouldn't need to use this class. We may hide it to internal in the future. 
             Currently we leave it public mainly for testing purpose. 
             </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.SpanWithPostBacks">
            <summary>
            Start a long Coversation that spans over multiple http requests
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.SpanWithCookie(System.String)">
            <summary>
            Start a long Coversation that spans over the whole session
            </summary>
            <param name="inWorkSpaceName">span in the work space</param>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.GiveUp">
            <summary>
            Give up the data change made in this conversation and stop spanning
            </summary>
            <remarks>
            This won't imediately close the conversation, it tells the conversation not to commit the DB change when it is closed. 
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.FinishSpan">
            <summary>
            tells the conversation to stop spanning itself and commit the data change made in it when it's closed
            </summary>
            <returns></returns>
            <remarks>
            call this method when all operations in a long span conversation are successfully done
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.Span(NHibernate.Burrow.Impl.SpanStrategy,System.String)">
            <summary>
            Add conversation to the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/>
            </summary>
            <remarks>
            if already in the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/>, do simply change the SpanStrategy if there is any change
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.StopSpanning">
            <summary>
            Remove this from the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/>
            </summary>
            <remarks>
            if not in the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/>, do nothing
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.CommitAndClose">
            <summary>
            Commit the data changes happened in this conversation and close it.
            </summary>
            <remarks>
            The NHibernate session will also be discard after you close the conversation
            </remarks>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.RollbackAndClose">
            <summary>
            immediately rollback 
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.Flush">
            <summary>
            Shortcut to flush the session
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.BeginNHibernateTransactions">
            <summary>
            Begin Transactions for all SessionManagers in All PersistenceUnits
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.CommitNHibernateTransactions">
            <summary>
            Commit Transactions for all SessionManagers in All PersistenceUnits
            </summary>
        </member>
        <member name="M:NHibernate.Burrow.Impl.ConversationImpl.GetSessionManager">
            <summary>
            The singleton Instance 
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.ConversationImpl.IsInPool">
            <summary>
            Indicates if this convesation is in the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/>
            </summary>
            <remarks>
            Conversation in the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/> will be persistent until they are closed.
            Conversation not in the <see cref="T:NHibernate.Burrow.Impl.ConversationPool"/> will be garbage collected once the httpContext or thread is discarded. 
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.ConversationImpl.SafeItems">
            <summary>
            Gets the data bag the conversation holds
            </summary>
            <remarks>
            You can use this item to store conversation span data
            </remarks>
        </member>
        <member name="P:NHibernate.Burrow.Impl.ConversationImpl.Id">
            <summary>
            Gets the unique id of this conversation
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.ConversationImpl.IsSpanning">
            <summary>
            Gets if this conversation is Spanning (either with Postbacks or HttpSessions)
            </summary>
        </member>
        <member name="P:NHibernate.Burrow.Impl.ConversationImpl.LastVisit">
            <summary>
            Gets the last time this conversation is visited
            </summary>
        </member>
    </members>
</doc>
