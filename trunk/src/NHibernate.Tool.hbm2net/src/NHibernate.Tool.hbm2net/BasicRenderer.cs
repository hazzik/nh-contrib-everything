using System;
using System.Collections;
using System.IO;
using System.Reflection;

using log4net;

using NHibernate.Util;

namespace NHibernate.Tool.hbm2net
{
	public class BasicRenderer : AbstractRenderer
	{
		private static readonly ILog log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

		public BasicRenderer()
		{
			InitBlock();
		}

		private void InitBlock()
		{
			languageTool = new LanguageTool();
			primitiveToObject["char"] = "Character";
			primitiveToObject["byte"] = "Byte";
			primitiveToObject["short"] = "Short";
			primitiveToObject["int"] = "Integer";
			primitiveToObject["long"] = "Long";
			primitiveToObject["boolean"] = "Boolean";
			primitiveToObject["float"] = "Float";
			primitiveToObject["double"] = "Double";
		}

		protected internal const int ORDINARY = 0;
		protected internal const int BOUND = 1;
		protected internal const int CONSTRAINT = 3; //any constraint properties are bound as well

		internal LanguageTool languageTool;

		public override void Render(string savedToPackage, string savedToClass, ClassMapping classMapping,
		                            IDictionary class2classmap, StreamWriter mainwriter)
		{
			mainwriter.WriteLine("using System;");
			mainwriter.WriteLine(
				@"//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
");
			GeneratePackageDelaration(savedToPackage, classMapping, mainwriter);
			mainwriter.WriteLine("{");

			// switch to another writer to be able to insert the actually
			// used imports when whole class has been rendered. 
			StringWriter writer = new StringWriter();


			// class declaration
			if (classMapping.GetMeta("class-description") == null)
			{
				writer.WriteLine(
					@" /// <summary>
 /// POJO for {0}
 /// </summary>
 /// <remark>
 /// This class is autogenerated
 /// </remark>
",
					classMapping.ClassName);
			}
			else
			{
				writer.WriteLine("/// <summary>\n" + languageTool.ToJavaDoc(classMapping.GetMetaAsString("class-description"), 0) +
				                 "\n/// </summary>");
			}

			string classScope = classMapping.Scope;
			string declarationType = classMapping.DeclarationType;


			//classMapping.addImport(typeof(System.Runtime.Serialization.ISerializable));
			//string modifiers = classMapping.getModifiers();
			if (classMapping.ShouldBeAbstract() && (classScope.IndexOf("abstract") == - 1))
			{
				writer.Write("abstract " + classScope + " " + declarationType + " " + savedToClass);
			}
			else
			{
				writer.Write(classScope + " " + declarationType + " " + savedToClass);
			}
			if (languageTool.HasExtends(classMapping) || languageTool.HasImplements(classMapping))
			{
				writer.Write(" : ");
			}

			if (languageTool.HasExtends(classMapping))
			{
				writer.Write(languageTool.GetExtends(classMapping));
			}

			if (languageTool.HasExtends(classMapping) && languageTool.HasImplements(classMapping))
			{
				writer.Write(", ");
			}

			if (languageTool.HasImplements(classMapping))
			{
				writer.Write(languageTool.GetImplements(classMapping));
			}

			writer.WriteLine(" {");
			writer.WriteLine();

			// switch to another writer to be able to insert the 
			// veto- and changeSupport fields
			StringWriter propWriter = new StringWriter();

			if (!classMapping.Interface)
			{
				DoFields(classMapping, class2classmap, propWriter);
				DoConstructors(savedToClass, classMapping, class2classmap, propWriter);
			}

			string vetoSupport = MakeSupportField("vetos", classMapping.AllFields);
			string changeSupport = MakeSupportField("changes", classMapping.AllFields);
			int fieldTypes = DoFieldAccessors(classMapping, class2classmap, propWriter, vetoSupport, changeSupport);

			if (!classMapping.Interface)
			{
				DoSupportMethods(fieldTypes, vetoSupport, changeSupport, propWriter);

				DoToString(classMapping, propWriter);

				DoEqualsAndHashCode(savedToClass, classMapping, propWriter);
			}
			if (classMapping.GetMeta("class-code") != null)
			{
				propWriter.WriteLine("// The following is extra code specified in the hbm.xml files");
				SupportClass.ListCollectionSupport extras = classMapping.GetMeta("class-code");
				IEnumerator iter = extras.GetEnumerator();
				while (iter.MoveNext())
				{
					string code = iter.Current.ToString();
					propWriter.WriteLine(code);
				}

				propWriter.WriteLine("// end of extra code specified in the hbm.xml files");
			}

			propWriter.WriteLine("}");

			//insert change and VetoSupport
			if (!classMapping.Interface)
			{
				DoSupports(fieldTypes, classMapping, vetoSupport, changeSupport, writer);
			}

			writer.Write(propWriter.ToString());

			// finally write the imports
			DoImports(classMapping, mainwriter);
			mainwriter.Write(writer.ToString());
			mainwriter.WriteLine("\n}");
		}

		/// <summary> Method doSupportMethods.</summary>
		/// <param name="changeSupport"></param>
		/// <param name="fieldTypes"></param>
		/// <param name="vetoSupport"></param>
		/// <param name="writer"></param>
		private void DoSupportMethods(int fieldTypes, string vetoSupport, string changeSupport, StringWriter writer)
		{
			if ((fieldTypes & CONSTRAINT) == CONSTRAINT)
			{
				writer.WriteLine("    public void addVetoableChangeListener( VetoableChangeListener l ) {");
				writer.WriteLine("        " + vetoSupport + ".addVetoableChangeListener(l);");
				writer.WriteLine("    }");
				writer.WriteLine("    public void removeVetoableChangeListener( VetoableChangeListener l ) {");
				writer.WriteLine("        " + vetoSupport + ".removeVetoableChangeListener(l);");
				writer.WriteLine("    }");
				writer.WriteLine();
			}
			if ((fieldTypes & BOUND) == BOUND)
			{
				writer.WriteLine("    public void addPropertyChangeListener( PropertyChangeListener l ) {");
				writer.WriteLine("        " + changeSupport + ".addPropertyChangeListener(l);");
				writer.WriteLine("    }");
				writer.WriteLine("    public void removePropertyChangeListener( PropertyChangeListener l ) {");
				writer.WriteLine("        " + changeSupport + ".removePropertyChangeListener(l);");
				writer.WriteLine("    }");
				writer.WriteLine();
			}
		}


		/// <summary> Method doSupports.</summary>
		/// <param name="vetoSupport">
		/// </param>
		/// <param name="changeSupport">
		/// </param>
		/// <param name="writer">
		/// </param>
		private void DoSupports(int fieldTypes, ClassMapping classMapping, string vetoSupport, string changeSupport,
		                        StringWriter writer)
		{
			if ((fieldTypes & CONSTRAINT) == CONSTRAINT)
			{
				writer.WriteLine("    private VetoableChangeSupport " + vetoSupport + " = new VetoableChangeSupport(this);");
				writer.WriteLine();
			}
			if ((fieldTypes & BOUND) == BOUND)
			{
				writer.WriteLine("    private PropertyChangeSupport " + changeSupport + " = new PropertyChangeSupport(this);");
				writer.WriteLine();
			}
		}


		public virtual void DoConstructors(string savedToClass, ClassMapping classMapping, IDictionary class2classmap,
		                                   StringWriter writer)
		{
			// full constructor
			SupportClass.ListCollectionSupport allFieldsForFullConstructor = classMapping.AllFieldsForFullConstructor;

			writer.WriteLine("    /// <summary>\n    /// full constructor\n    /// </summary>");
			string fullCons = "    public " + savedToClass + StringHelper.OpenParen;

			fullCons += languageTool.FieldsAsParameters(allFieldsForFullConstructor, classMapping, class2classmap);

			writer.Write(fullCons + ")");
			//invoke super to initialize superclass...
			SupportClass.ListCollectionSupport supersConstructorFields = classMapping.FieldsForSupersFullConstructor;
			if (!(supersConstructorFields.Count == 0))
			{
				writer.Write(" : base(");
				bool first = true;
				for (IEnumerator fields = supersConstructorFields.GetEnumerator(); fields.MoveNext();)
				{
					if (first)
						first = false;
					else
						writer.Write(", ");

					FieldProperty field = (FieldProperty) fields.Current;
					writer.Write(field.FieldName);
				}
				writer.Write(")");
			}
			writer.WriteLine();
			writer.WriteLine("    {");

			// initialisation of localfields
			for (IEnumerator fields = classMapping.LocalFieldsForFullConstructor.GetEnumerator(); fields.MoveNext();)
			{
				FieldProperty field = (FieldProperty) fields.Current;
				if (field.GeneratedAsProperty)
				{
					writer.WriteLine("        this." + field.FieldName + " = " + field.FieldName + ";");
				}
			}
			writer.WriteLine("    }");
			writer.WriteLine();

			// no args constructor (if fullconstructor had any arguments!)
			if (allFieldsForFullConstructor.Count > 0)
			{
				writer.WriteLine("    /// <summary>\n    /// default constructor\n    /// </summary>");
				writer.WriteLine("    public " + savedToClass + "() {");
				writer.WriteLine("    }");
				writer.WriteLine();
			}

			// minimal constructor (only if the fullconstructor had any arguments)
			if ((allFieldsForFullConstructor.Count > 0) && classMapping.NeedsMinimalConstructor())
			{
				SupportClass.ListCollectionSupport allFieldsForMinimalConstructor = classMapping.AllFieldsForMinimalConstructor;
				writer.WriteLine("    /// <summary>\n    /// minimal constructor\n    /// </summary>");

				string minCons = "    public " + savedToClass + "(";
				bool first = true;
				for (IEnumerator fields = allFieldsForMinimalConstructor.GetEnumerator(); fields.MoveNext();)
				{
					if (first)
						first = false;
					else
						minCons = minCons + ", ";

					FieldProperty field = (FieldProperty) fields.Current;
					minCons = minCons +
					          LanguageTool.ShortenType(LanguageTool.GetTrueTypeName(field, class2classmap), classMapping.Imports) + " " +
					          field.FieldName;
				}

				writer.Write(minCons + ")");
				// invoke super to initialize superclass...
				SupportClass.ListCollectionSupport supersMinConstructorFields = classMapping.FieldsForSupersMinimalConstructor;
				if (!(supersMinConstructorFields.Count == 0))
				{
					writer.Write(" : base(");
					bool first2 = true;
					for (IEnumerator fields = supersMinConstructorFields.GetEnumerator(); fields.MoveNext();)
					{
						if (first2)
							first2 = false;
						else
							writer.Write(StringHelper.CommaSpace);

						FieldProperty field = (FieldProperty) fields.Current;
						writer.Write(field.FieldName);
					}
					writer.Write(")");
				}
				writer.WriteLine();
				writer.WriteLine("    {");

				// initialisation of localfields
				for (IEnumerator fields = classMapping.LocalFieldsForMinimalConstructor.GetEnumerator(); fields.MoveNext();)
				{
					FieldProperty field = (FieldProperty) fields.Current;
					if (field.GeneratedAsProperty)
					{
						writer.WriteLine("        this." + field.FieldName + " = " + field.FieldName + ";");
					}
				}
				writer.WriteLine("    }");
				writer.WriteLine();
			}
		}

		public virtual void DoFields(ClassMapping classMapping, IDictionary class2classmap, StringWriter writer)
		{
			// fields
			if (!classMapping.Interface)
			{
				if (classMapping.SuperInterface)
				{
					DoFields(classMapping.AllFields, classMapping.Imports, class2classmap, writer);
				}
			}
			SupportClass.ListCollectionSupport fieldList = classMapping.Fields;
			SupportClass.SetSupport imports = classMapping.Imports;
			DoFields(fieldList, imports, class2classmap, writer);
		}

		private void DoFields(SupportClass.ListCollectionSupport fieldList, SupportClass.SetSupport imports,
		                      IDictionary class2classmap, StringWriter writer)
		{
			for (IEnumerator fields = fieldList.GetEnumerator(); fields.MoveNext();)
			{
				FieldProperty field = (FieldProperty) fields.Current;

				if (field.GeneratedAsProperty)
				{
					string fieldScope = GetFieldScope(field, "scope-field", "private");
					writer.WriteLine("    /// <summary>\n    /// Holder for " +
					                 (field.Nullable && !field.Identifier ? "nullable " : string.Empty) +
					                 (field.Identifier ? "identifier" : "persistent") + " field " + field.FieldName +
					                 "\n    /// </summary>");

					writer.Write("    " + fieldScope + " " + field.FullyQualifiedTypeName + " " + field.fieldcase);

					if (field.GetMeta("default-value") != null)
					{
						writer.Write(" = " + field.GetMetaAsString("default-value"));
					}
					writer.WriteLine(';');
				}
				writer.WriteLine();
			}
		}

		public virtual void DoEqualsAndHashCode(string savedToClass, ClassMapping classMapping, StringWriter writer)
		{
			if (classMapping.MustImplementEquals())
			{
				writer.WriteLine("    public override bool Equals(object obj) {");
				writer.WriteLine("        if(this == obj) return true;");
				writer.WriteLine("        if((obj == null) || (obj.GetType() != this.GetType())) return false;");
				writer.WriteLine("        " + savedToClass + " castObj = (" + savedToClass + ") obj;");
				writer.Write("        return (castObj != null) ");
				int usedFields = 0;
				SupportClass.ListCollectionSupport idFields = new SupportClass.ListCollectionSupport();
				for (IEnumerator fields = classMapping.Fields.GetEnumerator(); fields.MoveNext();)
				{
					FieldProperty field = (FieldProperty) fields.Current;
					if (field.GetMetaAsBool("use-in-equals"))
					{
						writer.Write(" && (this." + field.fieldcase + " == castObj." + field.fieldcase + ")");
						usedFields++;
					}
					if (field.Identifier)
					{
						idFields.Add(field);
					}
				}
				if (usedFields == 0)
				{
					log.Warn("No properties has been marked as being used in equals/hashcode for " + classMapping.Name +
					         ". Using object identifier which is RARELY safe to use! See http://hibernate.org/109.html");
					for (IEnumerator fields = idFields.GetEnumerator(); fields.MoveNext();)
					{
						FieldProperty field = (FieldProperty) fields.Current;
						writer.Write(" && (this." + field.fieldcase + " == castObj." + field.fieldcase + ")");
					}
				}
				writer.WriteLine(";");
				writer.WriteLine("    }");
				writer.WriteLine();

				writer.WriteLine("    public override int GetHashCode() {");
				writer.WriteLine("        int hash = 69;");
				//writer.Write("        return");

				for (IEnumerator fields = classMapping.Fields.GetEnumerator(); fields.MoveNext();)
				{
					FieldProperty field = (FieldProperty) fields.Current;
					if (field.GetMetaAsBool("use-in-equals"))
					{
						//writer.Write("\n            " + field.FieldName + ".GetHashCode() ^");
						writer.WriteLine("        hash = 31 * hash + " + field.fieldcase + ".GetHashCode();");
					}
				}
				if (usedFields == 0)
				{
					for (IEnumerator fields = idFields.GetEnumerator(); fields.MoveNext();)
					{
						FieldProperty field = (FieldProperty) fields.Current;
						//writer.Write("\n            " + field.FieldName + ".GetHashCode() ^");
						writer.WriteLine("        hash = 31 * hash + " + field.fieldcase + ".GetHashCode();");
					}
				}

				//writer.WriteLine(" 0;");
				writer.WriteLine("        return hash;");
				writer.WriteLine("    }");
				writer.WriteLine();
			}
		}

		public virtual void DoToString(ClassMapping classMapping, StringWriter writer)
		{
			writer.WriteLine("    public override string ToString()");
			writer.WriteLine("    {");
			writer.WriteLine("        System.Text.StringBuilder sb = new System.Text.StringBuilder();");
			for (IEnumerator fields = classMapping.AllFields.GetEnumerator(); fields.MoveNext();)
			{
				FieldProperty field = (FieldProperty) fields.Current;
				// If nothing is stated about id then include it in toString()
				if (field.Identifier && field.GetMeta("use-in-tostring") == null)
				{
					writer.WriteLine("        sb.AppendFormat(\"{0}={{0}} \", {0});", field.fieldcase);
				}
				else if (field.GetMetaAsBool("use-in-tostring"))
				{
					writer.WriteLine("        sb.AppendFormat(\"{0}={{0}} \", {0});", field.fieldcase);
				}
			}
			writer.WriteLine("        return sb.ToString();");
			writer.WriteLine("    }");
			writer.WriteLine();
		}

		internal static IDictionary primitiveToObject;

		public virtual int DoFieldAccessors(ClassMapping classMapping, IDictionary class2classmap, StringWriter writer,
		                                    string vetoSupport, string changeSupport)
		{
			int fieldTypes = ORDINARY;

			if (classMapping.SuperInterface)
			{
				fieldTypes =
					DoFields(classMapping, class2classmap, writer, vetoSupport, changeSupport, fieldTypes, classMapping.AllFields);
			}
			SupportClass.ListCollectionSupport fieldz = classMapping.Fields;
			fieldTypes = DoFields(classMapping, class2classmap, writer, vetoSupport, changeSupport, fieldTypes, fieldz);
			return fieldTypes;
		}

		private int DoFields(ClassMapping classMapping, IDictionary class2classmap, StringWriter writer, string vetoSupport,
		                     string changeSupport, int fieldTypes, SupportClass.ListCollectionSupport fieldz)
		{
			// field accessors
			for (IEnumerator fields = fieldz.GetEnumerator(); fields.MoveNext();)
			{
				FieldProperty field = (FieldProperty) fields.Current;
				if (field.GeneratedAsProperty)
				{
					// getter
					string getAccessScope = GetFieldScope(field, "scope-get", "public");


					if (field.GetMeta("field-description") != null)
					{
						//writer.WriteLine("    /** \n" + languageTool.toJavaDoc(field.getMetaAsString("field-description"), 4) + "     */");
						writer.WriteLine("    /// <summary>\n" + languageTool.ToJavaDoc(field.GetMetaAsString("field-description"), 4) +
						                 "\n    /// </summary>");
					}
					writer.Write("    " + getAccessScope + " virtual " + field.FullyQualifiedTypeName + " " + field.Propcase);
					if (classMapping.Interface)
					{
						writer.WriteLine(";");
					}
					else
					{
						writer.WriteLine();
						writer.WriteLine("    {");
						writer.WriteLine("        get { return this." + field.fieldcase + "; }");
						//writer.WriteLine("        {");
						//writer.WriteLine("            return this." + field.FieldName + ";");
						//writer.WriteLine("        }");
					}

					// setter
					int fieldType = 0;
					if (field.GetMeta("beans-property-type") != null)
					{
						string beansPropertyType = field.GetMetaAsString("beans-property-type").Trim().ToLower();
						if (beansPropertyType.Equals("constraint"))
						{
							fieldTypes = (fieldTypes | CONSTRAINT);
							fieldType = CONSTRAINT;
						}
						else if (beansPropertyType.Equals("bound"))
						{
							fieldTypes = (fieldTypes | BOUND);
							fieldType = BOUND;
						}
					}
					string setAccessScope = GetFieldScope(field, "scope-set", "public");
					writer.Write("        set");
					writer.Write((fieldType & CONSTRAINT) == CONSTRAINT ? " throws PropertyVetoException " : "");
					if (classMapping.Interface)
					{
						writer.WriteLine(";");
					}
					else
					{
						writer.WriteLine();
						writer.WriteLine("        {");
						if ((fieldType & CONSTRAINT) == CONSTRAINT || (fieldType & BOUND) == BOUND)
						{
							writer.WriteLine("            object oldValue = " + GetFieldAsObject(true, field) + ";");
						}
						if ((fieldType & CONSTRAINT) == CONSTRAINT)
						{
							writer.WriteLine("            " + vetoSupport + ".fireVetoableChange(\"" + field.fieldcase + "\",");
							writer.WriteLine("                    oldValue,");
							writer.WriteLine("                    " + GetFieldAsObject(false, field) + ");");
						}

						writer.WriteLine("            this." + field.fieldcase + " = value;");
						if ((fieldType & BOUND) == BOUND)
						{
							writer.WriteLine("            " + changeSupport + ".firePropertyChange(\"" + field.fieldcase + "\",");
							writer.WriteLine("                    oldValue,");
							writer.WriteLine("                    " + GetFieldAsObject(false, field) + ");");
						}
						writer.WriteLine("        }");
					}
					writer.WriteLine("    }");
					writer.WriteLine();

					// add/remove'rs (commented out for now)
					/* 
					if(field.getForeignClass()!=null) { 
					ClassName foreignClass = field.getForeignClass();
					
					string trueforeign = getTrueTypeName(foreignClass, class2classmap);
					classMapping.addImport(trueforeign);
					
					// Try to identify the matching set method on the child.
					ClassMapping forignMap = (ClassMapping) class2classmap.get(foreignClass.getFullyQualifiedName());
					
					if(forignMap!=null) {
					Iterator foreignFields = forignMap.getFields().iterator();
					while (foreignFields.hasNext()) {
					Field ffield = (Field) foreignFields.next();
					if(ffield.isIdentifier()) {
					log.Debug("Trying to match " + ffield.getName() + " with " + field.getForeignKeys());   
					}
					}
					
					} else {
					log.Error("Could not find foreign class's mapping - cannot provide bidirectional setters!");   
					}
					
					string addAccessScope = getFieldScope(field, "scope", "scope-add");
					writer.println("    " + setAccessScope + " void add" + field.getAsSuffix() + StringHelper.OPEN + shortenType(trueforeign, classMapping.getImports()) + " a" + field.getName() + ") {");
					writer.println("        this." + getterType + field.getAsSuffix() + "().add(a" + field.getName() + ");");
					writer.println("        a" + field.getName() + ".setXXX(this);");
					writer.println("    }");
					writer.println();
					
					
					}
					*/
				}
			}
			return fieldTypes;
		}

		public virtual void DoImports(ClassMapping classMapping, StreamWriter writer)
		{
			writer.WriteLine(languageTool.GenerateImports(classMapping));
			writer.WriteLine();
		}

		protected internal virtual string MakeSupportField(string fieldName, SupportClass.ListCollectionSupport fieldList)
		{
			string suffix = "";
			bool needSuffix = false;
			for (IEnumerator fields = fieldList.GetEnumerator(); fields.MoveNext();)
			{
				string name = ((FieldProperty) fields.Current).FieldName;
				if (name.Equals(fieldName))
					needSuffix = true;
				suffix += name;
			}
			return needSuffix ? fieldName + "_" + suffix : fieldName;
		}

		private string GetFieldAsObject(bool prependThis, FieldProperty field)
		{
			ClassName type = field.ClassType;
			if (type != null && type.Primitive && !type.Array)
			{
				string typeName = (String) primitiveToObject[type.Name];
				typeName = "new " + typeName + "( ";
				typeName += (prependThis ? "this." : "");
				return typeName + field.FieldName + " )";
			}
			return (prependThis ? "this." : "") + field.FieldName;
		}

		static BasicRenderer()
		{
			primitiveToObject = new Hashtable();
		}
	}
}